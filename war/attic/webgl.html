<!DOCTYPE html>
<html lang="en">
<head>
<title>WebGL</title>
<style type="text/css">
div.uniformsAttributes { height: 100px; overflow-y: scroll; }
div.vector input, table.matrix input { width: 3em; }
</style>
</head>
<body>
<canvas id="canvas" width="300" height="200"></canvas>
<div class="uniformsAttributes" id="node1">
<!--
<select class="">
  <optgroup label="Uniforms">
   <option>foo</option>
   <option>bar</option>
  </optgroup>
  <optgroup label="Attributes">
   <option>goo</option>
   <option>gar</option>
  </optgroup>
</select>
<table class="matrix">
  <tr>
    <td/>
    <th>x</th>
    <th>y</th>
    <th>z</th>
    <th>w</th>
  </tr>
  <tr>
    <th>x</th>
    <td><input name="xx" type="text"></input></td>
    <td><input name="yx" type="text"></input></td>
    <td><input name="zx" type="text"></input></td>
    <td><input name="wx" type="text"></input></td>
  </tr>
  <tr>
    <th>y</th>
    <td><input name="xy" type="text"></input></td>
    <td><input name="yy" type="text"></input></td>
    <td><input name="zy" type="text"></input></td>
    <td><input name="wy" type="text"></input></td>
  </tr>
  <tr>
    <th>z</th>
    <td><input name="xz" type="text"></input></td>
    <td><input name="yz" type="text"></input></td>
    <td><input name="zz" type="text"></input></td>
    <td><input name="wz" type="text"></input></td>
  </tr>
  <tr>
    <th>w</th>
    <td><input name="xw" type="text"></input></td>
    <td><input name="yw" type="text"></input></td>
    <td><input name="zw" type="text"></input></td>
    <td><input name="ww" type="text"></input></td>
  </tr>
</table>
<div class="vector">
  <input name="x" type="text" title="x/r"></input>
  <input name="y" type="text" title="y/g"></input>
  <input name="z" type="text" title="z/b"></input>
  <input name="w" type="text" title="w/a"></input>
</div>
<table class="matrix">
  <tr>
    <td><input name="xx" title="xx" type="text"></input></td>
    <td><input name="yx" type="text"></input></td>
    <td><input name="zx" type="text"></input></td>
    <td><input name="wx" type="text"></input></td>
  </tr>
  <tr>
    <td><input name="xy" type="text"></input></td>
    <td><input name="yy" type="text"></input></td>
    <td><input name="zy" type="text"></input></td>
    <td><input name="wy" type="text"></input></td>
  </tr>
  <tr>
    <td><input name="xz" type="text"></input></td>
    <td><input name="yz" type="text"></input></td>
    <td><input name="zz" type="text"></input></td>
    <td><input name="wz" type="text"></input></td>
  </tr>
  <tr>
    <td><input name="xw" type="text"></input></td>
    <td><input name="yw" type="text"></input></td>
    <td><input name="zw" type="text"></input></td>
    <td><input name="ww" type="text"></input></td>
  </tr>
</table>
-->
</div>
<textarea id="editor" style="width: 600px; height: 150px;">
precision mediump float;
uniform highp float foo;
uniform mat4 gao;
uniform int bar[3];
uniform sampler2D tiles;
uniform vec2 tile_size;
varying vec2 uv;
void main() {
  vec2 tile_id = floor(uv / tile_size);
  vec2 tile_coord = mod(uv, tile_size) * tile_size;
  gl_FragColor = vec4(mod(uv.x, 3.0), foo + bar[2] + gao[0][2]);
}
</textarea>
<script type="text/javascript">
function glIdToString(gl, id) {
  var string = null;
  for (key in gl) {
    if (gl[key] == id) {
      if (!string) {
        string = key;
      } else {
        string = string + " or " + key;
      }
    }
  }
  return string;
}

function CheckedGl(gl) {
  var checkedGl = {};
  var wrap = function(gl, func, name) {
//    console.log("Wrapping " + name + "(" + func + ")");
    return function() {
      var ret = func.apply(gl, arguments);
      var err = gl.getError();
      if (err != gl.NO_ERROR) {
        console.error(name + " caused " + glIdToString(gl, err));
      }
      return ret;
    }
  }
  for (key in gl) {
    if (typeof(gl[key]) == "function") {
      checkedGl[key] = wrap(gl, gl[key], key);
    } else {
      checkedGl[key] = gl[key];
    }
  }
  return checkedGl;
};

/*
(function() {
  var oldGetContext = HTMLCanvasElement.prototype.getContext;
  HTMLCanvasElement.prototype.getContext = function(id) {
    var context = oldGetContext.call(this, id);
    if (id == "experimental-webgl") {
      for (key in context) {
        if (typeof(context[key]) == "function") {
          
        }
      }
    }
    return context;
  };
})();
*/

function ShaderCompileException(logs) {
  this.logs = logs;
}

function Shader(gl, type, text) {
  this.gl = gl;
  this.type = type;
  this.listeners = [];
  if (text != null) {
    this.setText(text);
  }
}

Shader.prototype.setText = function(text) {
  var id = this.gl.createShader(this.type);
  this.gl.shaderSource(id, text);
  this.gl.compileShader(id);

  if (!this.gl.getShaderParameter(id, gl.COMPILE_STATUS)) {
    var glLogs = this.gl.getShaderInfoLog(id).split(/\n/);
    glLogs = glLogs.slice(0, glLogs.length - 1);
    var logs = [];
    for (var logIndex = 0; logIndex < glLogs.length; logIndex++) {
      var glLog = glLogs[logIndex];
      var logComponents = glLog.split(/:/);
      logs.push({type: logComponents[0].trim(),
                 column: parseInt(logComponents[1].trim()),
                 row: parseInt(logComponents[2].trim()),
                 message: logComponents.slice(3).join("")});
    }
    this.gl.deleteShader(id);
    throw new ShaderCompileException(logs);
  }

  this.text = text;
  if (this.id != null) {
    this.gl.deleteShader(this.id);
  }
  this.id = id;
  this.notifyListeners();
}

Shader.prototype.addListener = function(func) {
  this.listeners.push(func);
}

Shader.prototype.removeListener = function(func) {
  var listeners = [];
  for (var listenerIndex = 0; listenerIndex < this.listeners.length; listenerIndex++) {
    if (this.listeners[listenerIndex] != func) {
      listeners.push(func);
    }
  }
  this.listeners = listeners;
}

Shader.prototype.notifyListeners = function() {
  for (var listenerIndex = 0; listenerIndex < this.listeners.length; listenerIndex++) {
    this.listeners[listenerIndex]();
  }
}

function VertexShader(gl, text) {
  return new Shader(gl, gl.VERTEX_SHADER, text);
}

function FragmentShader(gl, text) {
  return new Shader(gl, gl.FRAGMENT_SHADER, text);
}

function Program(gl, vertexShader, fragmentShader) {
  this.gl = gl;
  this.vertexShader = vertexShader;
  this.fragmentShader = fragmentShader;
  this.id = gl.createProgram();
  var self = this;
  this.shaderListener = function() {
    self.update();
  }
  vertexShader.addListener(this.shaderListener);
  fragmentShader.addListener(this.shaderListener);
  this.update();
}

Program.prototype.update = function() {
  if ((this.vertexShader.id != null) &&
      (this.fragmentShader.id != null)) {
    this.gl.attachShader(this.id, this.vertexShader.id);
    this.gl.attachShader(this.id, this.fragmentShader.id);
    this.gl.linkProgram(this.id);
    if (!this.gl.getProgramParameter(this.id, gl.LINK_STATUS)) {
      console.log(this.gl.getProgramInfoLog(this.id));
    }

    var numUniforms = gl.getProgramParameter(prog.id, gl.ACTIVE_UNIFORMS);
    this.uniforms = [];
    for (var uniformIndex = 0; uniformIndex < numUniforms; uniformIndex++) {
      var uniform = gl.getActiveUniform(this.id, uniformIndex);
      this.uniforms.push({name: uniform.name.replace(/\[[0-9]+\]$/, ""),
                          type: glIdToString(gl, uniform.type),
                          size: uniform.size,
                          location: gl.getUniformLocation(this.id, uniform.name)});
                     
// BOOL, INT, FLOAT, BYTE?, SHORT?
// _VEC2, _VEC3, _VÂ£C4
// FLOAT_MAT2, FLOAT_MAT3, FLOAT_MAT4
// HIGH_FLOAT, HIGH_INT?, LOW_INT?, LOW_FLOAT?, MEDIUM_FLOAT?, MEDIUM_INT?
// UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_SHORT_4_4_4_4, UNSIGNED_SHORT_5_5_5_1, UNSIGNED_SHORT_5_6_%?

    }

    var numAttribs = gl.getProgramParameter(prog.id, gl.ACTIVE_ATTRIBUTES);
    this.attributes = [];
    for (var attribIndex = 0; attribIndex < numAttribs; attribIndex++) {
      var attrib = gl.getActiveAttrib(this.id, attribIndex);
      this.attributes.push({name: attrib.name.replace(/\[[0-9]+\]$/, ""),
                            type: glIdToString(gl, attrib.type),
                            size: attrib.size,
                            location: gl.getAttribLocation(this.id, attrib.name)});
    }
  }
}

Program.prototype.use = function() {
  this.gl.useProgram(this.id);
}


function Texture(gl, source) {
  this.gl = gl;
  this.id = gl.createTexture();
  this.setSource(source);
}

Texture.prototype.setSource = function(source) {
}


var canvas = document.getElementById("canvas");
var gl = canvas.getContext("experimental-webgl");
var vs = new VertexShader(gl,
"precision mediump float;\n" +
"attribute vec4 position;\n" +
"varying vec2 uv;\n" +
"void main() {\n" +
"  gl_Position = vec4((position.xy - 0.5) * 2.0, 0, 1);\n" +
"  uv = vec2(position.x, 1.0 - position.y);\n" +
"}");
var fs = new FragmentShader(gl);
var prog = new Program(gl, vs, fs);
var editor = document.getElementById("editor");
fs.setText(editor.value);

function createHTML(inputs) {
  var html = ' ';
  for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
    var input = inputs[inputIndex];
    for (var arrayIndex = 0; arrayIndex < input.size; arrayIndex++) {
      html += '<h3>' + input.name;
      if (input.size > 1) {
        html += '[' + arrayIndex + ']';
      }
      html += ' (' + input.type + ')</h3>';
      html += 
'<div class="vector">' +
'  <input id="input_' + input.name + '_' + inputIndex + 'x" type="text" title="x/r"></input>' +
'  <input id="input_' + input.name + '_' + inputIndex + 'y" type="text" title="y/g"></input>' +
'  <input id="input_' + input.name + '_' + inputIndex + 'z" type="text" title="z/b"></input>' +
'  <input id="input_' + input.name + '_' + inputIndex + 'w" type="text" title="w/a"></input>' +
'</div>';
    }
  }
}

function updateValue(gl, name, type) {
}

document.getElementById("node1").innerHTML = createHTML(prog.uniforms) + createHTML(prog.attributes);

prog.use();
</script>
</body>
</html>
